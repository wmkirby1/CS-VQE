############    Fermionic Quantum Computation Suite      ########################    Jake Seeley (jseeley@haverford.edu)      ########################           June 2011-June 2012            #################################################################################### Revision mid-2014:  Added functionality to store integrals as multi ## dimensional arrays. - Andrew Tranter (a.tranter13@imperial.ac.uk    ########################################################################from numpy import *from sets import *
from copy import *import copyPAULI_STRING_MIN_COEFFICIENT = float("1e-16")###### TOOLS ######def pcheck(integer):    """Return TRUE if input integer is even, FALSE if odd."""        if integer%2 == 0:        return True    else:        return Falsedef vmodtwo(vector):    """Take a list of integers and return a list of the mod 2 versions of those integers."""        output = len(vector)*[0]    for i in range(len(vector)):        output[i] = vector[i]%2    return outputdef matmodtwo(matrix):    """Take an array of integers and return an array of the mod 2 versions of those integers."""        output = zeros(shape(matrix),dtype = int)    for i in range(shape(matrix)[0]):        for j in range(shape(matrix)[1]):            output[i,j] = matrix[i,j]%2    return output    def string_to_list(string):    """Return a list of the characters in the input string."""    list = [0]*len(string)    for j in range(len(string)):        list[j] = int(string[j])    return listdef list_to_string(list):    """Return a string made from the items in the input list"""    string = ''    for j in range(len(list)):        string = string + str(list[j])    return stringdef index_conv(i):    """Express an index using our right-zeroed convention in Python's left-zeroed system."""        return -i-1def index_set_conv(oldindexset):    """Express a list of right-indexed indices as a list of Python left-zeroed indices."""    N = len(oldindexset)    newindexset = [0]*N    for i in range(N):        newindexset[i] = index_conv(oldindexset[i])    return newindexsetdef num(ket):    """Return the number that corresponds to the bits of a ket (when treated as a binary string)."""        return integer(list_to_string(ket.bitlist))def part_sum(bitlist,indices):    """Compute the mod 2 sum of the subset of bits in bitlist given by the list of indices."""        sum = 0    for x in indices:        sum = sum^bitlist[x]    return sumdef integer(binary):    """Convert a binary string to a base-10 integer."""        bits = string_to_list(binary)    p = len(bits)    result = 0    for j in range(p):        result = result + bits[j]*pow(2,p-j-1)    return resultdef binary(integer):    """Return the binary string that represents a base-10 integer."""        return bin(integer)[2:]def list_zero(list):    """Takes a list of numbers as input and returns the 'similar' list that starts at 0.    E.g.    input: [3,6,7]    output: [0,3,4]    """        output = []    for x in range(len(list)):        output.append(list[x]-list[0])    return outputdef list_fill(list):    """Take an ordered list of integers and return a list with any gaps filled in.    E.g.    input: [1,3,8]    output: [1,2,3,4,5,6,7,8]    """        output = []    for i in range(list[0],list[-1]+1):        output.append(i)    return outputdef size(list):    """Return the number of elements in the filled-in version of an ordered list of integers.    E.g.    input: [2,7,19]    output: 18    """        return int(list[-1] - list[0] + 1)def binary_basis_build(basissize):    """Create a dictionary of the binary strings with the number of bits in basissize.    E.g.    input: 3    output: {0: '000', 1: '001', 2: '010', 3: '011', 4: '100', 5: '101', 6: '110', 7: '111'}        """        binary_basis = {}    for j in range(pow(2,basissize)):        string = binary(j).zfill(basissize)        binary_basis[j] = string    return binary_basisdef ket_basis_build(basissize):    """Create a dictionary of the occupation number basis kets with the number of bits in basissize.    E.g.    input: 3    output: {0: |0 0 0>, 1: |0 0 1>, 2: |0 1 0>, 3: |0 1 1>, 4: |1 0 0>, 5: |1 0 1>, 6: |1 1 0>, 7: |1 1 1>}        """        binary_basis = binary_basis_build(basissize)    ket_basis = {}    for x in binary_basis:        ket_basis[x] = ket(binary_basis[x])    return ket_basisdef bkbasis(jwbasis):    """Create a dictionary of the Bravyi-Kitaev basis kets from a dictionary of occupation number basis kets.    E.g.    input: {0: |0 0 0>, 1: |0 0 1>, 2: |0 1 0>, 3: |0 1 1>, 4: |1 0 0>, 5: |1 0 1>, 6: |1 1 0>, 7: |1 1 1>}    output: {0: |0 0 0>, 1: |0 1 1>, 2: |0 1 0>, 3: |0 0 1>, 4: |1 0 0>, 5: |1 1 1>, 6: |1 1 0>, 7: |1 0 1>}        """        bk = {}    for x in jwbasis:        bk[x] = bravyi(jwbasis[x])    return bkdef matrix_build(basis1,basis2):    """Create a change-of-basis matrix that takes kets in basis1 to kets in basis2 with the same key.    E.g.    inputs:            basis1 = {0: |0 0 0>, 1: |0 0 1>, 2: |0 1 0>, 3: |0 1 1>, 4: |1 0 0>, 5: |1 0 1>, 6: |1 1 0>, 7: |1 1 1>}            basis2 = {0: |0 0 0>, 1: |0 1 1>, 2: |0 1 0>, 3: |0 0 1>, 4: |1 0 0>, 5: |1 1 1>, 6: |1 1 0>, 7: |1 0 1>}    output:            array([[1, 0, 0, 0, 0, 0, 0, 0],                   [0, 0, 0, 1, 0, 0, 0, 0],                   [0, 0, 1, 0, 0, 0, 0, 0],                   [0, 1, 0, 0, 0, 0, 0, 0],                   [0, 0, 0, 0, 1, 0, 0, 0],                   [0, 0, 0, 0, 0, 0, 0, 1],                   [0, 0, 0, 0, 0, 0, 1, 0],                   [0, 0, 0, 0, 0, 1, 0, 0]])    """                       n = len(basis1)    matrix = zeros((n,n),dtype=int)                                                     for j in basis2:                                                                        if basis2[j].exists:                                                                    if basis2[j].sign != basis1[j].sign:                                                    matrix[integer(list_to_string(basis2[j].bitlist)),\                       integer(list_to_string(basis1[j].bitlist))] = -1            else:                                                                                   matrix[integer(list_to_string(basis2[j].bitlist)),\                       integer(list_to_string(basis1[j].bitlist))] = 1    return matrixdef array_equals(array1,array2):# The following function checks whether two arrays are identical in every entry. Arrays must have same shape.    Tval = True    for i in range(shape(array1)[0]):        for j in range(shape(array1)[0]):            if array1[i,j] != array2[i,j]:                Tval = False                break    return Tvaldef kronecker_build(arraylist):# Takes a list of arrays (here intended to be single-qubit quantum gates such as X or Z) and returns their tensor product, i.e. the matrix that# acts on the state of the quantum computer by acting with the j-th array on the j-th qubit.    n = len(arraylist)    if n == 1:        return arraylist[0]    output = kron(arraylist[0],arraylist[1])    for j in range(2,n):        output = kron(output,arraylist[j])    return outputdef op_builder(oplist):# Takes a list of arrays and returns their dot product.    n = len(oplist)    if n == 1:        return oplist[0]    else:        output = dot(oplist[0],oplist[1])        for j in range(2,n):            output = dot(output,oplist[j])        return outputdef commutes(matrix1,matrix2):# Takes two matrices as inputs and returns true if they commute and false if they don't.    return array_equals(dot(matrix1,matrix2)-dot(matrix2,matrix1),zeros(shape(matrix1)))def anti_commutes(matrix1,matrix2):# Takes two matrices as inputs and returns true if they anti-commute and false if they don't.    return array_equals(dot(matrix1,matrix2)+dot(matrix2,matrix1),zeros(shape(matrix1)))def set_diff(list1,list2):    return list(set(list1)-set(list2))   def E_proj(bit_indices):    n = size(bit_indices)    matrix = eye(pow(2,n),dtype=int)    for i in range(pow(2,n)):        if part_sum(string_to_list(binary(i).zfill(n)),index_set_conv(list_zero(bit_indices)))==1:            matrix[i,i] = 0    return matrixdef O_proj(bit_indices):    n = size(bit_indices)    matrix = eye(pow(2,n),dtype=int)    for i in range(pow(2,n)):        if part_sum(string_to_list(binary(i).zfill(n)),index_set_conv(list_zero(bit_indices)))==0:            matrix[i,i] = 0    return matrix###### BASIS VECTORS ######class ket:# Here we define the class "ket", which has user-friendly display properties.    def __init__(self, bits):    # New instances of class ket are initialized with a string of bits, e.g. ket('101001')    # Attribute 'bitlist' contains a list of the user-supplied bits    # Attribute 'sign' keeps track of the sign of the state vector. 0 means positive, 1 means negative. (In general this should be a complex phase).    # Attribute 'exists' is a switch that allows a state vector to be turned on or off (annihilated)            self.bitlist = string_to_list(bits)            self.sign = 0                                                                                self.exists = True                                          def __repr__(self):    # Define the ket representation for displaying state vectors        if not self.exists:                                         return  '| n u l l >'                                      else:            disp = []            if self.sign:                disp.append('-')                                    disp.append('|')            for j in range(len(self.bitlist)):                if j != len(self.bitlist)-1:                                disp.append(str(self.bitlist[j]))                    disp.append(' ')                else:                    disp.append(str(self.bitlist[j]))                       disp.append('>')            return list_to_string(disp)    def __eq__(self,other):    # Define equivalence between kets        if self.bitlist == other.bitlist and self.sign == other.sign and self.exists == other.exists:            return True        else:            return False    def __getitem__(self,b):    # Define how to call bits from instances of class ket        return self.bitlist[b]def ket_copy(state):# Make an identical copy of a ket    output = ket(list_to_string(state.bitlist))    output.sign = state.sign    output.exists = state.exists    return outputdef ket_kill(state):# Take a ket and returns a copy that has been switched off (annihilated)    output = ket_copy(state)    output.exists = False    return output###### CREATION AND ANNIHILATION OPERATORS ######class ferm_op:    def __init__(self,j,n,an_cr,JW_BK):        self.dim = n        self.index = j        if an_cr == 1:            self.kind = 'Creation'        if an_cr == 0:            self.kind = 'Annihilation'        if JW_BK == 0:            self.encoding = 'Jordan-Wigner'        if JW_BK == 1:            self.encoding = 'Bravyi-Kitaev'        self.oplist = oplist_create(j,n,an_cr,JW_BK)        self.algexp = cleandisplay(self.oplist)    def __repr__(self):                return self.kind + ' operator acting on qubit ' + str(self.index) + ' of ' + str(self.dim) + ' total qubits in the ' + self.encoding + ' basis.'    def op(self,state):        if self.encoding == 'Jordan-Wigner':            if self.kind == 'Creation':                return jw_cr_op(state,self.index)            if self.kind == 'Annihilation':                return jw_an_op(state,self.index)        if self.encoding == 'Bravyi-Kitaev':            if self.kind == 'Creation':                return bk_cr_op(state,self.index)            if self.kind == 'Annihilation':                return bk_an_op(state,self.index)        ###### QUANTUM GATES ######def sX(state,target):# Sigma X on the target bit of a ket.    output = ket_copy(state)    output.bitlist[target] = output.bitlist[target]^1    return outputdef c_sX(state,control,target):# This function applies the X gate to the target bit (flips it) if the control bit is set to one.    output = ket_copy(state)    output.bitlist[target] = output.bitlist[control]^output.bitlist[target]    return outputdef sZ(state,target):# Sigma Z on the target bit.    output = ket_copy(state)    output.sign = output.sign^output.bitlist[target]    return outputdef c_sZ(state,control,target):# This function applies the Z gate to the target bit if the control bit is set to one.    output = ket_copy(state)    if output.bitlist[control] == 1:        if output.bitlist[target] == 1:            output.sign = output.sign^1    return outputI = array([[1,0],[0,1]])Z = array([[1,0],[0,-1]])X = array([[0,1],[1,0]])Y = array([[0,0-1j],[0+1j,0]])Plus = array([[0,1],[0,0]])Minus = array([[0,0],[1,0]])zero = array([1,0])one = array([0,1])even_proj = outer(zero,zero)odd_proj = outer(one,one)###### JORDAN-WIGNER ######def jw_cr_op(state,j):# This function uses the J-W mapping to construct the creation operators that act on Fock space vectors. Inputs are a# Fock space ket and a target bit index, and the output is the ket that results from the action of the operator.    if state.bitlist[index_conv(j)] == 1:        return ket_kill(state)    if state.bitlist[index_conv(j)] == 0:        output = ket_copy(state)        output.bitlist[index_conv(j)] = 1        if not pcheck(state.bitlist[index_conv(j-1):].count(1)) and j != 0:            output.sign = state.sign^1        return outputdef jw_cr_matrix(j,n):# This function creates the (2^n X 2^n) matrix representation in the occupation basis of the creation operator acting on orbital j.     arraylist = n*[I]    arraylist[index_conv(j)] = Minus    for i in index_set_conv(range(j)):        arraylist[i] = Z    return kronecker_build(arraylist)    def jw_an_op(state,j):# This function uses the J-W mapping to construct the annihilation operators that act on Fock space vectors. Inputs are a# Fock space ket and a target bit index, and the output is the ket that results from the action of the operator.    if state.bitlist[index_conv(j)] == 0:        return ket_kill(state)    if state.bitlist[index_conv(j)] == 1:        output = ket_copy(state)        output.bitlist[index_conv(j)] = 0        if not pcheck(state.bitlist[index_conv(j-1):].count(1)) and j != 0:            output.sign = state.sign^1        return outputdef jw_an_matrix(j,n):# This function creates the (2^n X 2^n) matrix representation in the Fock basis of the annihilation operator acting on orbital j.    arraylist = n*[I]    arraylist[index_conv(j)] = Plus    for i in index_set_conv(range(j)):        arraylist[i] = Z    return kronecker_build(arraylist)def bf_jw_an(j,n):    kets = ket_basis_build(pow(2,n))    matrix = zeros((pow(2,n),pow(2,n)),dtype = int)    for x in kets:        if jw_an_op(kets[x],j).exists and not jw_an_op(kets[x],j).sign:            matrix[num(jw_an_op(kets[x],j)),x] = 1        if jw_an_op(kets[x],j).exists and jw_an_op(kets[x],j).sign:            matrix[num(jw_an_op(kets[x],j)),x] = -1    return matrixdef bf_jw_cr(j,n):    kets = ket_basis_build(pow(2,n))    matrix = zeros((pow(2,n),pow(2,n)),dtype = int)    for x in kets:        if jw_cr_op(kets[x],j).exists and not jw_cr_op(kets[x],j).sign:            matrix[num(jw_cr_op(kets[x],j)),x] = 1        if jw_cr_op(kets[x],j).exists and jw_cr_op(kets[x],j).sign:            matrix[num(jw_cr_op(kets[x],j)),x] = -1    return matrix###### BRAVYI-KITAEV ######def bravyi_set(q):# This function takes an input index q and returns the set of indices of occupation numbers that are included in the# partial sum b_q in the Bravyi-Kitaev encoding.    Q = binary(q)    prt_ord = []    for i in range(len(Q)+1):        if Q[i:].count('1') == len(Q[i:]):                              for j in range(integer(Q[i:])+1):                               prt_ord.append(q-j)                             break    return sorted(prt_ord)def bravyi(fock):# This function transforms Fock space vectors to the Bravyi-Kitaev basis.    Bravyi = ket_copy(fock)    for i in range(len(Bravyi.bitlist)):        Bravyi.bitlist[index_conv(i)] = part_sum(fock.bitlist, index_set_conv(bravyi_set(i)))    return Bravyidef inv_bravyi(bravyi):# This function transforms Bravyi-Kitaev-encoded kets back into Fock space.    Fock = ket_copy(bravyi)    for i in range(len(bravyi.bitlist)):        Fock.bitlist[index_conv(i)] = Fock.bitlist[index_conv(i)] ^ part_sum(bravyi.bitlist,index_set_conv(flip_set(i)))    return Fockdef update_set(j,n):## Occupation numbers are in general stored non-locally in the Bravyi-Kitaev basis, so when the occupation of orbital j changes, there is a set## of qubits that must be changed. The following function takes as inputs an index and a total number of orbitals (qubits) and returns the set of## indices of qubits that must be updated.    U = []    for i in range(j+1,n):        if j in bravyi_set(i):            U.append(i)    return Udef flip_set(j):# The flip set determines whether Bravyi-Kitaev qubit j is flipped with respect to the occupancy of orbital j.    J = binary(j)    K = []    for i in range(len(J)+1):        if J[i:].count('1') == len(J[i:]):            for k in range(J[i:].count('1')):                K.append(j-pow(2,k))            break    return sorted(K)    def parity_set(j):# The parity set includes the indices of Bravyi-Kitaev qubits that store the parity of occupied orbitals with index less than j.    J = binary(j)    L = []    counter = -1    for i in range(len(J)):        if int(J[i]) == 1:            counter = counter + pow(2,len(J)-i-1)            L.append(counter)    return sorted(L)    def R_set(j):    if j%2 == 0:        return []    P = parity_set(j)    F = flip_set(j)    R = set_diff(P,F)    R.sort()    return Rdef bf_bk_an(j,n):    kets = ket_basis_build(pow(2,n))    bk_kets = bkbasis(kets)    for x in kets:        kets[x] = bravyi(jw_an_op(kets[x],j))    return matrix_build(bk_kets,kets)   def bf_bk_cr(j,n):    kets = ket_basis_build(pow(2,n))    bk_kets = bkbasis(kets)    for x in kets:        kets[x] = bravyi(jw_cr_op(kets[x],j))    return matrix_build(bk_kets,kets)def bk_cr_op(state,j):    output = ket_copy(state)    if j%2 == 0:        if state.bitlist[index_conv(j)] == 0:            output.bitlist[index_conv(j)] = 1            if not pcheck(part_sum(state.bitlist,index_set_conv(parity_set(j)))):                output.sign = output.sign^1        if state.bitlist[index_conv(j)] == 1:            return ket_kill(output)    if not j%2 == 0:        if pcheck(part_sum(state.bitlist,index_set_conv(flip_set(j)))):            if state.bitlist[index_conv(j)] == 0:                output.bitlist[index_conv(j)] = 1            if state.bitlist[index_conv(j)] == 1:                return ket_kill(output)        if not pcheck(part_sum(state.bitlist,index_set_conv(flip_set(j)))):            if state.bitlist[index_conv(j)] == 1:                output.bitlist[index_conv(j)] = 0                output.sign = output.sign^1            if state.bitlist[index_conv(j)] == 0:                return ket_kill(output)    for i in update_set(j,len(state.bitlist)):        output.bitlist[index_conv(i)] = output.bitlist[index_conv(i)]^1    return outputdef bk_cr_matrix(j,n):    if j%2 == 0:        arraylist = n*[I]        arraylist[index_conv(j)] = Minus        for i in parity_set(j):            arraylist[index_conv(i)] = Z        for k in update_set(j,n):            arraylist[index_conv(k)] = X    if not j%2 == 0:        N = n - size(flip_set(j))        arraylist = N*[I]        for i in I_set(j):            arraylist[index_conv(i)] = Z        arraylist[index_conv(flip_set(j)[0])] = cr_proj(j)        for i in update_set(j,n):            arraylist[index_conv(i-size(flip_set(j)))] = X    return kronecker_build(arraylist)def cr_proj(j):    return kron(Minus,E_proj(flip_set(j)))-kron(Plus,O_proj(flip_set(j)))    def bk_an_op(state,j):    output = ket_copy(state)    if j%2 == 0:        if state.bitlist[index_conv(j)] == 1:            output.bitlist[index_conv(j)] = 0            if not pcheck(part_sum(state.bitlist,index_set_conv(parity_set(j)))):                output.sign = output.sign^1        if state.bitlist[index_conv(j)] == 0:            return ket_kill(output)    if not j%2 == 0:        if pcheck(part_sum(state.bitlist,index_set_conv(flip_set(j)))):            if state.bitlist[index_conv(j)] == 1:                output.bitlist[index_conv(j)] = 0            if state.bitlist[index_conv(j)] == 0:                return ket_kill(output)        if not pcheck(part_sum(state.bitlist,index_set_conv(flip_set(j)))):            if state.bitlist[index_conv(j)] == 0:                output.bitlist[index_conv(j)] = 1                output.sign = output.sign^1            if state.bitlist[index_conv(j)] == 1:                return ket_kill(output)    for i in update_set(j,len(state.bitlist)):        output.bitlist[index_conv(i)] = output.bitlist[index_conv(i)]^1    return outputdef bk_an_matrix(j,n):    if j%2 == 0:        arraylist = n*[I]        arraylist[index_conv(j)] = Plus        for i in parity_set(j):            arraylist[index_conv(i)] = Z        for k in update_set(j,n):            arraylist[index_conv(k)] = X    if not j%2 == 0:        N = n - size(flip_set(j))        arraylist = N*[I]        for i in I_set(j):            arraylist[index_conv(i)] = Z        arraylist[index_conv(flip_set(j)[0])] = an_proj(j)        for i in update_set(j,n):            arraylist[index_conv(i-size(flip_set(j)))] = X    return kronecker_build(arraylist)def an_proj(j):    return kron(Plus,E_proj(flip_set(j)))-kron(Minus,O_proj(flip_set(j)))###### PARITY BASIS ######def parity(fock):# This function takes a ket in Fock space and returns the corresponding ket in the parity basis.    parity = ket_copy(fock)    for i in range(len(fock.bitlist)):        parity.bitlist[i] = sum(fock.bitlist[:i+1])%2    return paritydef inv_parity(parity):# This function takes a ket in the parity basis and returns the corresponding ket in Fock space.    fock = ket_copy(parity)    fock.bitlist[0] = parity.bitlist[0]    for j in range(1,len(parity.bitlist)):        fock.bitlist[j] = parity.bitlist[j]^parity.bitlist[j-1]    return fockdef par_cr_op(state,j):# This function applies the creation operator that acts on kets in the parity basis. Inputs are a# parity basis ket and a target bit index, and the output is the ket that results from the action of the operator.    if state.bitlist[j-1]^state.bitlist[j]== 1:        return ket_kill(state)    if state.bitlist[j-1]^state.bitlist[j] == 0:        output = ket_copy(state)        if state.bitlist[j-1] == 0:            output.bitlist[j] = 1        else:            output.bitlist[j] = 0        output = sZ(output,j-1)        for i in range(j+1,len(state.bitlist)):            output = sX(output,i)        return outputdef par_an_op(state,j):# This function applies the annihilation operator that acts on kets in the parity basis. Inputs are a# parity basis ket and a target bit index, and the output is the ket that results from the action of the operator.    if state.bitlist[j-1]^state.bitlist[j]== 0:        return ket_kill(state)    if state.bitlist[j-1]^state.bitlist[j] == 1:        output = ket_copy(state)        if state.bitlist[j-1] == 0:            output.bitlist[j] = 1        else:            output.bitlist[j] = 1        output = sZ(output,j-1)        for i in range(j+1,len(state.bitlist)):            output = sX(output,i)        return output    ############## Tests ########def test_encoding(n):    a = ket_basis_build(pow(2,n))    b = bkbasis(a)    for i in range(n):        for x in a:            A = {}            B = {}            C = {}            D = {}            A[x] = bravyi(jw_cr_op(a[x],i))            B[x] = bk_cr_op(b[x],i)            C[x] = bravyi(jw_an_op(a[x],i))            D[x] = bk_an_op(b[x],i)                    print A == B, C == Ddef test_ops(n):    for i in range(2,n+1):        for j in range(i):            print array_equals(bf_bk_an(j,i), bk_an_matrix(j,i)), array_equals(bf_bk_cr(j,i), bk_cr_matrix(j,i))    def __repr__(self):                return self.kind + ' operator acting on qubit ' + str(self.index) + ' of ' + str(self.dim) + ' total qubits in the ' + self.encoding + ' basis.'    def transmatrix(n):    I = array([[1,0],[0,1]])    dim = int(ceil(log2(n)))    output = array([[1]])    for i in range(dim):        output = kron(I,output)        output[0] = pow(2,i+1)*[1]    size = shape(output)[1]-n    output = output[size:,size:]    return outputdef newBK(occupation):    bits = occupation.bitlist    n = len(bits)    newbits = dot(transmatrix(n),bits)    newbits = vmodtwo(newbits)    BK = ket(list_to_string(newbits))    return BKdef newbkbasis(jwbasis):    bk = {}    for x in jwbasis:        bk[x] = newBK(jwbasis[x])    return bkdef bigtransmatrix(n):    a = ket_basis_build(pow(2,n))    b = newbkbasis(a)    return matrix_build(a,b)#####################################def dec_conv(base,bits):    output = 0    for i in range(len(bits)):        output = output + bits[i]*pow(base,dispindex(i,len(bits)))    return outputdef dispindex(pyindex,n):    return n - 1 - pyindexdef cleancomplex(compnum):    if compnum.imag != 0 and compnum.real != 0:        return 'EEEE'    elif compnum.imag == 0:        if compnum.real > 0:            return '+' + str(compnum.real)        if compnum.real < 0:            return str(compnum.real)    elif compnum.imag != 0:        if compnum.imag > 0:            return '+' + str(compnum.imag) + ' i'        if compnum.imag < 0:            return str(compnum.imag) + ' i'        def oplist_create(j,n,an_cr,JW_BK):    oplist = [[.5*(1+0j),n*[0]],[.5*(0+1j),n*[0]]]    if an_cr == 1:        oplist[1][0] = .5*(0-1j)    oplist[0][1][index_conv(j)] = 1    oplist[1][1][index_conv(j)] = 2    if JW_BK == 0:        for k in range(dispindex(j,n)+1,n):            oplist[0][1][k] = 3            oplist[1][1][k] = 3                if JW_BK == 1:        for k in update_set(j,n):            oplist[0][1][index_conv(k)] = 1            oplist[1][1][index_conv(k)] = 1        for k in parity_set(j):            oplist[0][1][index_conv(k)] = 3        if j%2 == 0:            for k in parity_set(j):                oplist[1][1][index_conv(k)] = 3        if j%2 == 1:            for k in R_set(j):                oplist[1][1][index_conv(k)] = 3                    return oplistdef coefficient(coeff,oplist):    for i in range(len(oplist)):        oplist[i][0] = coeff*oplist[i][0]    return oplistdef pauliletter(num):    if num == 0:        return 'Id'    if num == 1:        return 'X'    if num == 2:        return 'Y'    if num == 3:        return 'Z'def pauliprod(twoplist):    phase = 1 + 0j        if twoplist[0] == 0:        return [phase,twoplist[1]]    if twoplist[1] == 0:        return [phase,twoplist[0]]        if twoplist[0] == 1:        if twoplist[1] == 1:            return [phase,0]        if twoplist[1] == 2:            phase = 0 + 1j            return [phase,3]        if twoplist[1] == 3:            phase = 0 - 1j            return [phase, 2]                        if twoplist[0] == 2:        if twoplist[1] == 1:            phase = 0 - 1j            return [phase,3]        if twoplist[1] == 2:            return [phase,0]        if twoplist[1] == 3:            phase = 0 + 1j            return [phase, 1]    if twoplist[0] == 3:        if twoplist[1] == 1:            phase = 0 + 1j            return [phase,2]        if twoplist[1] == 2:            phase = 0 - 1j            return [phase,1]        if twoplist[1] == 3:            return [phase,0]def op_prod(op1,op2):    phase = op1[0]*op2[0]    newnumlist = []    for i in range(len(op1[1])):        [cphase,newnum] = pauliprod([op1[1][i],op2[1][i]])        newnumlist.append(newnum)        phase = cphase*phase    return [phase,newnumlist]          def simplify(oplist,ignorePrecision=1):    '''added precision check to prevent propagation of float arithmetic errors -AET'''    import copy    import decimal    if not ignorePrecision:        newOplist = copy.deepcopy(oplist)        newOplist.sort(key = lambda item: item[1])            k = 0        precision = 0 #int describing number of significant figures for most accurate re(coefficient) and im(coefficient)                for op in newOplist:            thing = op[0]            if thing.real:                realPrecision = abs(decimal.Decimal(str(thing.real)).as_tuple()[2])                if realPrecision > precision:                    precision = realPrecision+2              if thing.imag:                imagPrecision = abs(decimal.Decimal(str(thing.imag)).as_tuple()[2])                if imagPrecision > precision:                    precision = imagPrecision+2        '''                while k < len(newOplist) - 1:            if newOplist[k][1] == newOplist[k+1][1]:                newOplist[k][0] = newOplist[k][0]+newOplist[k+1][0]                if abs(newOplist[k][0].real) < float('1e-'+str(precision)):                    newOplist[k][0] = complex(0,(newOplist[k][0].imag))                if abs(newOplist[k][0].imag) < float('1e-'+str(precision)):                    newOplist[k][0] = complex(newOplist[k][0].real,0)                                del newOplist[k+1]                continue            if newOplist[k][1] != newOplist[k+1][1]:                k = k+1                 '''                   while k < len(newOplist) - 1:            if newOplist[k][1] == newOplist[k+1][1]:                decimalCoefficient1Real = decimal.Decimal(str(newOplist[k][0].real))                decimalCoefficient2Real = decimal.Decimal(str(newOplist[k+1][0].real))                decimalCoefficient1Imag = decimal.Decimal(str(newOplist[k][0].imag))                decimalCoefficient2Imag = decimal.Decimal(str(newOplist[k+1][0].imag))                totalReal = decimalCoefficient1Real+decimalCoefficient2Real                totalImag = decimalCoefficient1Imag+decimalCoefficient2Imag                newCoefficient = complex(totalReal,totalImag)                newOplist[k][0] = newCoefficient                del newOplist[k+1]                continue            if newOplist[k][1] != newOplist[k+1][1]:                k = k+1                        k = 0        while k < len(newOplist):            if newOplist[k][0] == 0:                del newOplist[k]                continue            if newOplist[k][0] != 0:                k = k+1                return newOplist    else:        seen = {}        for item in oplist:            pString = tuple(item[1])            if pString in seen:                seen[pString] += item[0]            else:                seen[pString] = item[0]        newOplist = [[x[1],list(x[0])] for x in seen.items()]        newOplist.sort(key = lambda item: item[1])         return newOplist         def oplist_prod(oplist1,oplist2,noSimplify=0):    result = []    for i in range(len(oplist1)):        for j in range(len(oplist2)):            op = op_prod(oplist1[i],oplist2[j])            result.append(op)    if not noSimplify:        result = simplify(result)    return resultdef oplist_sum(list_of_oplists,noSimplify=0):    result = []    for i in range(len(list_of_oplists)):        for j in range(len(list_of_oplists[i])):            result.append(list_of_oplists[i][j])    if not noSimplify:        result = simplify(result)    return resultdef oplistRemoveNegligibles(oplist,cutoff = PAULI_STRING_MIN_COEFFICIENT):    newOplist = []    if not cutoff == -1:        for opstring in oplist:            if absolute(opstring[0]) > cutoff:                newOplist.append(opstring)    else:         return oplist    return newOplistdef negate(op):    op[0] = -1*op[0]    return op    def pauliterm(numlist):    string = ''    if numlist == len(numlist)*[0]:        return 'Id '    for i in range(len(numlist)):        if numlist[i] != 0:            string = string + pauliletter(numlist[i]) + str(dispindex(i,len(numlist))) + ' '    return stringdef cleandisplay(oplist):    string = ''    for i in range(len(oplist)):        string = string + cleancomplex(oplist[i][0]) + ' ' + pauliterm(oplist[i][1])    return string    def twoprod(i,j,n,option1,option2,JW_BK,coeff = 1):    op1 = ferm_op(i,n,option1,JW_BK)    op2 = ferm_op(j,n,option2,JW_BK)    result = oplist_prod(op1.oplist,op2.oplist)    result = coefficient(coeff,result)    return resultdef fourprod(i,j,k,l,n,option1,option2,option3,option4,JW_BK,coeff = 1):    #if (coeff == 0 or coeff == 0.): #yes, i know.     #   return []    op1 = ferm_op(i,n,option1,JW_BK)    op2 = ferm_op(j,n,option2,JW_BK)    op3 = ferm_op(k,n,option3,JW_BK)    op4 = ferm_op(l,n,option4,JW_BK)    result = oplist_prod(oplist_prod(op1.oplist,op2.oplist),oplist_prod(op3.oplist,op4.oplist))    result = coefficient(coeff,result)    return result########################class num_op:    def __init__(self,i,n,JW_BK,coeff = 1):        self.oplist = twoprod(i,i,n,1,0,JW_BK,coeff)    def __repr__(self):        return cleandisplay(self.oplist)    def laTex(self):        print latex(self.oplist)class excite_op:    def __init__(self,i,j,n,JW_BK,coeff = 1):        self.oplist = oplist_sum([twoprod(i,j,n,1,0,JW_BK,coeff),twoprod(j,i,n,1,0,JW_BK,coeff)])            def __repr__(self):        return cleandisplay(self.oplist)    def laTex(self):        print latex(self.oplist)class coulomb_op:    def __init__(self,i,j,n,JW_BK,coeff = 1):        self.oplist = fourprod(i,j,j,i,n,1,1,0,0,JW_BK,coeff)    def __repr__(self):        return cleandisplay(self.oplist)    def laTex(self):        print latex(self.oplist)class num_excite_op:    def __init__(self,p,q,r,n,JW_BK,coeff = 1):        self.oplist = oplist_sum([fourprod(p,q,q,r,n,1,1,0,0,JW_BK,coeff),fourprod(r,q,q,p,n,1,1,0,0,JW_BK,coeff)])    def __repr__(self):        return cleandisplay(self.oplist)    def laTex(self):        print latex(self.oplist)class dbl_excite_op:    def __init__(self,p,q,r,s,n,JW_BK,coeff = 1):        self.oplist = oplist_sum([fourprod(p,q,r,s,n,1,1,0,0,JW_BK,coeff),fourprod(s,r,q,p,n,1,1,0,0,JW_BK,coeff)])    def __repr__(self):        return cleandisplay(self.oplist)    def laTex(self):        print latex(self.oplist)    #########################def oneE_terms(n):    terms = []    for i in range(n):        for j in range(n):            terms.append([i,j])    return termsdef oneEints(n):    ints = []    for i in range(n):        for j in range(n):            if i == j:                ints.append(1)            else:                ints.append(0)    return intsdef twoEints(n):    ints = []    for i in range(n):        for j in range(n):            for k in range(n):                for l in range(n):                    if i != j and k != l:                        ints.append([i,j,k,l])    return intsdef twoE_terms(n):    terms = []    for i in range(n):        for j in range(n):            for k in range(n):                for l in range(n):                    terms.append([i,j,k,l])    return termsoneE_ints = [-1.25,0,0,0,0,-1.25,0,0,0,0,-.48,0,0,0,0,-.48]oneE_ints2 = [1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1]oneE_ints3 = [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]testOneElectronIntegrals = array([[-1.252477, -0.      ,  0.      ,  0.      ],       [-0.      , -1.252477,  0.      ,  0.      ],       [ 0.      ,  0.      , -0.475934, -0.      ],       [ 0.      ,  0.      , -0.      , -0.475934]])'''testTwoElectronIntegrals = [[[[0, 0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0,]],                             [[ 0, 0, 0, 0.67], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0.18, 0, 0]],                             [[ 0, 0.18, 0, 0], [0, 0, 0, 0.66], [0, 0, 0, 0], [0, 0, 0, 0]],                              [[0, 0, 0, 0], [0, 0.18, 0, 0], [0, 0, 0, 0.66], [0, 0, 0, 0]]],                                                         [[[0.67, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0]],                             [[0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0]],                             [[0, 0, 0, 0], [0, 0, 0, 0.66], [0, 0, 0, 0], [0, 0, 0, 0]],                             [[0, 0, 0, 0], [0, 0.18, 0, 0], [0, 0, 0, 0.66], [0, 0, 0, 0]]],                                                          [[[0.66, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0]],                              [[0, 0, 0, 0], [0.66, 0, 0, 0], [0, 0, 0.18, 0], [0, 0, 0, 0]],                               [[0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0]],                            [[0, 0.18, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0.7], [0, 0, 0, 0]]],                                                         [[[0.66, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0]],                             [[0, 0, 0, 0], [0.66, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0]],                             [[0, 0, 0, 0], [0, 0, 0, 0], [0.7, 0, 0, 0], [0, 0, 0, 0]],                            [[0, 0, 0, 0], [0, 0, 0, 0], 0, 0, 0, 0, 0]'''                            testTwoElectronIntegrals = array([[[[ 0.67449309,  0.        ,  0.        ,  0.        ],         [ 0.        ,  0.        ,  0.        ,  0.        ],         [ 0.        ,  0.        ,  0.18128754,  0.        ],         [ 0.        ,  0.        ,  0.        ,  0.        ]],        [[ 0.        ,  0.        ,  0.        ,  0.        ],         [ 0.67449309,  0.        ,  0.        ,  0.        ],         [ 0.        ,  0.        ,  0.        ,  0.        ],         [ 0.        ,  0.        ,  0.18128754,  0.        ]],        [[ 0.        ,  0.        ,  0.18128754,  0.        ],         [ 0.        ,  0.        ,  0.        ,  0.        ],         [ 0.66347203,  0.        ,  0.        ,  0.        ],         [ 0.        ,  0.        ,  0.        ,  0.        ]],        [[ 0.        ,  0.        ,  0.        ,  0.        ],         [ 0.        ,  0.        ,  0.18128754,  0.        ],         [ 0.        ,  0.        ,  0.        ,  0.        ],         [ 0.66347203,  0.        ,  0.        ,  0.        ]]],       [[[ 0.        ,  0.67449309,  0.        ,  0.        ],         [ 0.        ,  0.        ,  0.        ,  0.        ],         [ 0.        ,  0.        ,  0.        ,  0.18128754],         [ 0.        ,  0.        ,  0.        ,  0.        ]],        [[ 0.        ,  0.        ,  0.        ,  0.        ],         [ 0.        ,  0.67449309,  0.        ,  0.        ],         [ 0.        ,  0.        ,  0.        ,  0.        ],         [ 0.        ,  0.        ,  0.        ,  0.18128754]],        [[ 0.        ,  0.        ,  0.        ,  0.18128754],         [ 0.        ,  0.        ,  0.        ,  0.        ],         [ 0.        ,  0.66347203,  0.        ,  0.        ],         [ 0.        ,  0.        ,  0.        ,  0.        ]],        [[ 0.        ,  0.        ,  0.        ,  0.        ],         [ 0.        ,  0.        ,  0.        ,  0.18128754],         [ 0.        ,  0.        ,  0.        ,  0.        ],         [ 0.        ,  0.66347203,  0.        ,  0.        ]]],       [[[ 0.        ,  0.        ,  0.66347203,  0.        ],         [ 0.        ,  0.        ,  0.        ,  0.        ],         [ 0.18128754,  0.        ,  0.        ,  0.        ],         [ 0.        ,  0.        ,  0.        ,  0.        ]],        [[ 0.        ,  0.        ,  0.        ,  0.        ],         [ 0.        ,  0.        ,  0.66347203,  0.        ],         [ 0.        ,  0.        ,  0.        ,  0.        ],         [ 0.18128754,  0.        ,  0.        ,  0.        ]],        [[ 0.18128754,  0.        ,  0.        ,  0.        ],         [ 0.        ,  0.        ,  0.        ,  0.        ],         [ 0.        ,  0.        ,  0.69739794,  0.        ],         [ 0.        ,  0.        ,  0.        ,  0.        ]],        [[ 0.        ,  0.        ,  0.        ,  0.        ],         [ 0.18128754,  0.        ,  0.        ,  0.        ],         [ 0.        ,  0.        ,  0.        ,  0.        ],         [ 0.        ,  0.        ,  0.69739794,  0.        ]]],       [[[ 0.        ,  0.        ,  0.        ,  0.66347203],         [ 0.        ,  0.        ,  0.        ,  0.        ],         [ 0.        ,  0.18128754,  0.        ,  0.        ],         [ 0.        ,  0.        ,  0.        ,  0.        ]],        [[ 0.        ,  0.        ,  0.        ,  0.        ],         [ 0.        ,  0.        ,  0.        ,  0.66347203],         [ 0.        ,  0.        ,  0.        ,  0.        ],         [ 0.        ,  0.18128754,  0.        ,  0.        ]],        [[ 0.        ,  0.18128754,  0.        ,  0.        ],         [ 0.        ,  0.        ,  0.        ,  0.        ],         [ 0.        ,  0.        ,  0.        ,  0.69739794],         [ 0.        ,  0.        ,  0.        ,  0.        ]],        [[ 0.        ,  0.        ,  0.        ,  0.        ],         [ 0.        ,  0.18128754,  0.        ,  0.        ],         [ 0.        ,  0.        ,  0.        ,  0.        ],         [ 0.        ,  0.        ,  0.        ,  0.69739794]]]])twoE_ints = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0.67, 0, 0, 0, 0, 0, 0,             0, 0, 0, 0.18, 0, 0, 0, 0.18, 0, 0, 0, 0, 0, 0.66, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,             0, 0, 0.18, 0, 0, 0, 0, 0, 0.66, 0, 0, 0, 0, 0.67, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,             0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,             0.66, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0.18, 0, 0, 0, 0, 0, 0.66, 0, 0, 0, 0,             0.66, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0.66, 0, 0, 0, 0, 0,             0.18, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0.18, 0,             0, 0, 0, 0, 0, 0, 0, 0, 0.7, 0, 0, 0, 0, 0.66, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,             0, 0, 0, 0, 0, 0, 0, 0.66, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,             0.7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]twoE_ints2 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0,             0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,             0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,             0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,             1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0,             1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0,             1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0,             0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,             0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,             1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]twoE_ints3 = 256*[1]def argh(blah):    indices = [0,1,2,3]    bob = empty([4,4,4,4])    for i in indices:        for j in indices:            for l in indices:                for k in indices:                    bob[i][j][k][l] = blah[(i*64 + j*16 + k*4 + l)]    return bobdef oneE_H(n, JW_BK, integrals = oneE_ints):    terms = oneE_terms(n)    oplist = []    for i in range(len(terms)):        oplist.append(twoprod(terms[i][0],terms[i][1],n,1,0,JW_BK,integrals[i]))    oplist = oplist_sum(oplist)        return oplistdef oneElectronHamiltonian(numOrbitals,boolJordanOrBravyi, integrals = testOneElectronIntegrals,verbose=False):    '''calculate the one electron hamiltonian    numOrbitals: integer number of orbitals    boolJordanOrBravyi:  boolean, 0 for jordan-wigner mapping, 1 for bravyi-kitaev mapping    integrals:  2D tensor of one electron integrals'''    oplist = []    for i in range(numOrbitals):        for j in range(numOrbitals):            if verbose:                print(str(i)+str(j))            oplist.append(twoprod(i,j,numOrbitals,1,0,boolJordanOrBravyi,integrals[i][j]))    oplist = oplist_sum(oplist)    oplist = oplistRemoveNegligibles(oplist)    return oplistdef twoE_H(n,JW_BK, integrals = twoE_ints):    terms = twoE_terms(n)    oplist = []    for i in range(len(terms)):        oplist.append(fourprod(terms[i][0],terms[i][1],terms[i][2],terms[i][3],n,1,1,0,0,JW_BK,.5*integrals[i]))    oplist = oplist_sum(oplist)    return oplistdef twoElectronHamiltonian(numOrbitals,boolJordanOrBravyi, integrals = testTwoElectronIntegrals, negateIntegrals = False,verbose=False):    '''calculate the two electron hamiltonian    numOrbitals: integer number of orbitals    boolJordanOrBravyi:  boolean, 0 for jordan-wigner mapping, 1 for bravyi-kitaev mapping    integrals:  4D tensor of two electron integrals'''    oplist = []    for i in range(numOrbitals):        for j in range(numOrbitals):            for k in range(numOrbitals):                for l in range(numOrbitals):                    if integrals[i][j][k][l]:                        if verbose:                            print(str(i)+str(j)+str(k)+str(l))                        oplist.append(fourprod(i,j,k,l,numOrbitals,1,1,0,0,boolJordanOrBravyi,(1 - 2*negateIntegrals) * 0.5*integrals[i][j][k][l]))    oplist = oplist_sum(oplist)    oplist = oplistRemoveNegligibles(oplist)    return oplistdef electronicHamiltonian(numOrbitals,boolJordanOrBravyi,oneEIntegrals=testOneElectronIntegrals,twoEIntegrals=testTwoElectronIntegrals, negateTwoEIntegrals=False,verbose=False):    oplist = oplist_sum([oneElectronHamiltonian(numOrbitals,boolJordanOrBravyi,oneEIntegrals,verbose),twoElectronHamiltonian(numOrbitals,boolJordanOrBravyi,twoEIntegrals,negateTwoEIntegrals,verbose)])    return oplistdef E_Ham(n,JW_BK, ints1 = oneE_ints, ints2 = twoE_ints):    oplist = oplist_sum([oneE_H(n,JW_BK,integrals = oneE_ints),twoE_H(n,JW_BK,integrals = twoE_ints)])    return oplistdef james_Ham(JW_BK):    op1 = num_op(0,4,JW_BK,-1.252477).oplist    op2 = num_op(1,4,JW_BK,-1.252477).oplist    op3 = num_op(2,4,JW_BK,-0.475934).oplist    op4 = num_op(3,4,JW_BK,-0.475934).oplist    op5 = coulomb_op(0,1,4,JW_BK,0.674493).oplist    op6 = coulomb_op(2,3,4,JW_BK,0.697397).oplist    op7 = coulomb_op(0,3,4,JW_BK,0.663472).oplist    op8 = coulomb_op(1,2,4,JW_BK,0.663472).oplist    op9 = coulomb_op(0,2,4,JW_BK,0.482185).oplist    op10 = coulomb_op(1,3,4,JW_BK,0.482185).oplist    op11 = dbl_excite_op(0,3,1,2,4,JW_BK,0.181287).oplist    op12 = dbl_excite_op(0,1,3,2,4,JW_BK,0.181287).oplist    oplist = oplist_sum([op1,op2,op3,op4,op5,op6,op7,op8,op9,op10,op11,op12])    return oplistdef james_oneH(JW_BK):    op1 = num_op(0,4,JW_BK,-1.252477).oplist    op2 = num_op(1,4,JW_BK,-1.252477).oplist    op3 = num_op(2,4,JW_BK,-0.475934).oplist    op4 = num_op(3,4,JW_BK,-0.475934).oplist    oplist = oplist_sum([op1,op2,op3,op4])    return oplistdef james_twoH(JW_BK):    op5 = coulomb_op(0,1,4,JW_BK,0.674493).oplist    op6 = coulomb_op(2,3,4,JW_BK,0.697397).oplist    op7 = coulomb_op(0,3,4,JW_BK,0.663472).oplist    op8 = coulomb_op(1,2,4,JW_BK,0.663472).oplist    op9 = coulomb_op(0,2,4,JW_BK,0.482185).oplist    op10 = coulomb_op(1,3,4,JW_BK,0.482185).oplist    op11 = dbl_excite_op(0,3,1,2,4,JW_BK,0.181287).oplist    op12 = dbl_excite_op(0,1,3,2,4,JW_BK,0.181287).oplist    oplist = oplist_sum([op5,op6,op7,op8,op9,op10,op11,op12])    return oplist##############################def latex(oplist):    string = '$'    for i in range(len(oplist)):        string = string + latexterm(oplist[i])    string = string + '$'    return stringdef latexterm(op):        string = cleancomplex(op[0]) + '\ '    string = string + sigmaterm(op[1])    return stringdef sigma(num):    if num == 0:        return 'Id'    if num == 1:        return 'x'    if num == 2:        return 'y'    if num == 3:        return 'z'def sigmaterm(numlist):    if numlist == len(numlist)*[0]:        return '\I'    string = ''    for i in range(len(numlist)):        if numlist[i] != 0:            string = string + '\sigma_{' + str(dispindex(i,len(numlist))) + '}^' + sigma(numlist[i])    string = string + '\ '    return string    def Y_set(i,j,n):    upseti = update_set(i,n)    psetj = parity_set(j)    return set(upseti).intersection(set(psetj))def X_set(i,j,n):    upseti = update_set(i,n)    upsetj = update_set(j,n)    return set(upseti).symmetric_difference(set(upsetj))def coulombnums(i,j,n):    nums1 = set(flip_set(i)).union(set([i]))    nums2 = set(flip_set(j)).union(set([j]))    numslist = []    numslist.append(nums1)    numslist.append(nums2)    numslist.append(nums1.symmetric_difference(nums2))    return numslistdef listops(oplist):    for term in oplist:        xlist = []        ylist = []        zlist = []        for i in range(len(term[1])):            if term[1][i] == 1:                xlist.append(dispindex(i,len(term[1])))            if term[1][i] == 2:                ylist.append(dispindex(i,len(term[1])))            if term[1][i] == 3:                zlist.append(dispindex(i,len(term[1])))        print 'X:', xlist        print 'Y:', ylist        print 'Z:', zlist        print '---------------------------'                             def support(paulilist):    supp = []    for i in range(len(paulilist)):        if paulilist[i] != 0:            supp.append(dispindex(i,len(paulilist)))    return suppdef symcommutes(op1,op2):    a = op_prod([1,op1],[1,op2])    b = negate(op_prod([1,op2],[1,op1]))    return oplist_sum([[a],[b]]) == []                def comm_group(oplist):    groups = []    while len(oplist) > 0:        groupinds = [0]        for i in range(1,len(oplist)):            if symcommutes(oplist[0][1],oplist[i][1]):                groupinds.append(i)            group = []            for x in groupinds:                oplistcopy = oplist[:]                print(x)                group.append(oplistcopy[x])                oplist.remove(oplistcopy[x])            groups.append(group)            continue    return groupsdef oplistCoefficientNorm(oplist):    if not isinstance(oplist[0],list):        return abs(oplist[0])    else:        norm = 0        for op in oplist:            norm = norm + (op[0] ** 2)        norm = sqrt(norm)    return norm            def groupedOplistsDeviation(listOplists):    '''calculate the standard deviation of the norm of the coefficients of the terms within each group.'''    listNorms = [0]*len(listOplists)    for i in range(len(listOplists)):        listNorms[i] = oplistCoefficientNorm(listOplists[i])    sd = std(listNorms)    return sddef doesTermCommuteWithGroup(op,groupOplist):    if not isinstance(groupOplist[0],list):        return checkCommute(op,groupOplist)    for groupOp in groupOplist:        if not checkCommute(op,groupOp):            return False    return Truedef doGroupsCommute(group1,group2):    for op1 in group1:        for op2 in group2:            if not checkCommute(op1[1],op2[1]):                return False    return True    def oplistToGroups(oplist):    groups = []    for op in oplist:        groups.append([op])    return groupsdef findBestGroupMerge(group,listGroups):    '''take one group of oplists and a list of grouped oplists, find the best choice of merger    including just having the first group as a new group in the list'''    listGroups.append(group)    bestStandardDeviation = groupedOplistsDeviation(listGroups)    listGroups.pop()    lengthGroup = len(group)    currentBestGroupMergeIndex = -1    for i in range(len(listGroups)):        if doGroupsCommute(group,listGroups[i]):            listGroups[i] = listGroups[i] + group            thisStandardDeviation = groupedOplistsDeviation(listGroups)            if abs(thisStandardDeviation) < abs(bestStandardDeviation):                bestStandardDeviation = thisStandardDeviation                currentBestGroupMergeIndex = i            listGroups[i] = listGroups[i][:-lengthGroup]    return (currentBestGroupMergeIndex,bestStandardDeviation)            def greedyGroupPickMerge(listGroups):    bestStandardDeviation = groupedOplistsDeviation(listGroups)    bestGroupToMergeIndex = -1    bestRelativeMergeIndex = -1    for i in range(len(listGroups)):        thisGroup = listGroups.pop(i)        (mergeIndex,thisStandardDeviation) = findBestGroupMerge(thisGroup,listGroups)        if abs(thisStandardDeviation) < abs(bestStandardDeviation):            bestStandardDeviation = thisStandardDeviation            bestGroupToMergeIndex = i            bestRelativeMergeIndex = mergeIndex        listGroups.insert(i,thisGroup)    return(bestGroupToMergeIndex,bestRelativeMergeIndex)            def mergeRelative(listGroups, groupToMergeIndex, relativeMergeIndex):    groupToMerge = listGroups.pop(groupToMergeIndex)    listGroups[relativeMergeIndex] = listGroups[relativeMergeIndex] + groupToMerge    return listGroups                        def greedyGroupOplist(oplist):    listGroups = copy.deepcopy(oplist)    listGroups = oplistToGroups(listGroups)    boolFinished = 0    while not boolFinished:        (bestGroupToMergeIndex,bestRelativeMergeIndex) = greedyGroupPickMerge(listGroups)        if ((not (bestGroupToMergeIndex == -1)) and (not (bestRelativeMergeIndex == -1))):            listGroups = mergeRelative(listGroups,bestGroupToMergeIndex,bestRelativeMergeIndex)        else:            boolFinished = 1    return listGroupsdef groupCommutingTerms(rawHamiltonian):    '''group commuting terms in a hamiltonian, return a list of groups.    note for now this randomly selects terms to find other commuting terms,    iterates MAX_ITERATIONS times, selecting the best choice.    obviously this is not the best way of doing this.        TODO:  !!!! make this return explicitly, at the moment the interpreter can    get confused and references to different subgroups can cause the groups to be    recalculated, leading to the subgroups being different, leading to chaos.!!! '''    import time    startTime = time.clock()    MAX_ITERATIONS = 1    storedGroupsList = []    numStoredGroups = -1        for iteration in range(MAX_ITERATIONS): #try procedure MAX_ITERATIONS times        unsortedHamiltonian = list(rawHamiltonian)        newGroupsList = []                while len(unsortedHamiltonian) > 0: #while we have unsorted terms in the Hamiltonian            randomIndex = random.random_integers(0,len(unsortedHamiltonian)-1)            firstTermInNewGroup = list(unsortedHamiltonian[randomIndex])            newGroup = [firstTermInNewGroup]            unsortedHamiltonian.pop(randomIndex)            tmpUnsortedHamiltonian = list(unsortedHamiltonian)            for term in unsortedHamiltonian:                boolAddTerm = 1                 for termInNewGroup in newGroup: #for all terms in the group                        #abort if we've already detected noncommutativity                    if not checkCommute(termInNewGroup[1],term[1]): #check commutativity                        boolAddTerm = 0 #don't add term if noncommutativity                        break #                   if boolAddTerm == 1: #having checked term against entire subset, add term if commutes with all.                if boolAddTerm:                    newGroup.append(term)                    tmpUnsortedHamiltonian.remove(term)                                newGroupsList.append(newGroup)            unsortedHamiltonian = list(tmpUnsortedHamiltonian)            #newGroupsList.append(newGroup)                                                              #  if symcommutes(firstTermInNewGroup[1],term[1]): #index 1 as 0 is the coefficient, 1 is the pauli string               #     newGroup.append(term)                #    tmpUnsortedHamiltonian.remove(term) #will bug if there's duplicate terms.  shouldn't ever be, though.        print(len(newGroupsList))               if ((len(newGroupsList) > numStoredGroups) or numStoredGroups < 1): #check to see if this iteration "beats the current record"                   storedGroupsList = list(newGroupsList)            numStoredGroups = len(storedGroupsList)                                endTime = time.clock()    print(endTime-startTime)    return storedGroupsListdef stuff(thing):    fred = electronicHamiltonian(18,0,thing[0],thing[1])    jim = groupCommutingTerms(fred)    return jim            def normalOrder(fermionicTerm,compatMode=True):    '''take a product of fermionic operators as a list [coefficient, [terms]].        !!!!!NB at present, input MUST already have all creation operators on the left hand side!!!!    TODO: generalise    '''    coefficient = fermionicTerm[0]    ops = list(fermionicTerm[1])    for i in range(1,len(ops)):        for j in range(i,0,-1):            leftOp = ops[j-1]            rightOp = ops[j]            if rightOp > leftOp:                ops[j-1]=rightOp                ops[j]=leftOp                coefficient = -1. * coefficient            else:                break    return [coefficient,ops]def build1ElectronFermionHamiltonian(nOrbitals,integrals):    hamiltonian = {}    for i in range(nOrbitals):        for j in range(nOrbitals):            if integrals[i][j]:                hamiltonian[(i+1,-(j+1))] = integrals[i][j]    return hamiltoniandef build2ElectronFermionHamiltonian(nOrbitals,integrals):    hamiltonian = {}    for i in range(nOrbitals):        for j in range(nOrbitals):            for k in range(nOrbitals):                for l in range(nOrbitals):                    if integrals[i][j][k][l]:                        termList = [integrals[i][j][k][l]/2, [i+1,j+1,-(k+1),-(l+1)]]                        normalOrdered = normalOrder(termList)                        try:                            hamiltonian[tuple(normalOrdered[1])] = hamiltonian[tuple(normalOrdered[1])] + normalOrdered[0]                        except:                            hamiltonian[tuple(normalOrdered[1])] = normalOrdered[0]    return hamiltoniandef buildFermionicHamiltonian(nOrbitals,oneElectronIntegrals,twoElectronIntegrals):    oneElectronHamiltonian = build1ElectronFermionHamiltonian(nOrbitals,oneElectronIntegrals)    twoElectronHamiltonian = build2ElectronFermionHamiltonian(nOrbitals,twoElectronIntegrals)    hamiltonian = dict(oneElectronHamiltonian.items() + twoElectronHamiltonian.items())    return hamiltonian                                       ##################################################################################################################################################################################### operators using symplectic notation ##########def simplify_qubit_term(qubit,sup):	#given the support of the X, Y, and Z term for some term XYZ, given some qubit, 	#simplifies to one pauli matrix that acts on that qubit	paulis_on_q=[[1,[1,0]],[1,[1,1]],[1,[0,1]]]	for i in range(3):		if qubit not in sup[i]:			paulis_on_q[i]=[1,[0,0]] #if qubit not in support then change matrix to identity	simplified_term=symp_mult(symp_mult(paulis_on_q[0],paulis_on_q[1]),paulis_on_q[2])	return simplified_termdef symp_mult(symp1,symp2):	#symp must be a 2 element array that hold the coefficient for the pauli matrix 	#and the two symplectic entires, i.e. if symp =[a,[b,c]] --> a*(b,c) in symplectic notation	p1,q1=symp1[1]	p2,q2=symp2[1]	#print symp1[0],symp2[0]		#calc. new coeff due to multiplication of coeffs and phase shift	new_coeff=symp1[0]*symp2[0]*(1j**((p2*q1-p1*q2)*(2*(p1+p2-q1-q2)+1)))	#print new_coeff	p=(p1+p2)% 2	#print p	q=(q1+q2)% 2 	#print q	symp=[new_coeff,[p,q]]	return sympdef sup_createanni(i,n):#find the support of the creation and annihilation operators	US=update_set(i,n)	PS=parity_set(i)	FS=parity_set(i)	RS=R_set(i)	x1=list(Set(US).symmetric_difference(Set([i])))	y1=[]	z1=PS	x2=US	y2=[i]	z2=RS		term1_sup=[x1,y1,z1]	term2_sup=[x2,y2,z2]	return[term1_sup,term2_sup]def cr_symp(i,n):	#creation op. in symplectic notation and with terms seperated by qubit	# i.e. a+ = b*sigma_p(0)*sigma_q(1)*...*sigma_r(n) (p,q,r = {I,x,y,z})	sup=sup_createanni(i,n)	term1=[0.5] #[coef,term1,term2,term3,...,termn]	paulis1=[]	term2=[-0.5j]	paulis2=[]	for q in range(n):		t1=simplify_qubit_term(q,sup[0])		paulis1.append(t1[1])		term1[0]=term1[0]*t1[0]		t2=simplify_qubit_term(q,sup[1])		paulis2.append(t2[1])		term2[0]=term2[0]*t2[0]	term1.append(paulis1)	term2.append(paulis2)	return [term1,term2]	def an_symp(i,n):	sup=sup_createanni(i,n)	term1=[0.5] #terms in form [coef,termq0,termq1,termq2,...,termqn]	paulis1=[]	term2=[0.5j]	paulis2=[]	for q in range(n):		t1=simplify_qubit_term(q,sup[0])		paulis1.append(t1[1])		term1[0]=term1[0]*t1[0]		t2=simplify_qubit_term(q,sup[1])		paulis2.append(t2[1])		term2[0]=term2[0]*t2[0]	term1.append(paulis1)	term2.append(paulis2)	return [term1,term2]	def comb_terms(op_long):	simplified=[]	unq_pauli_terms=[]	pauli_terms=[]
	op=[] #create array to hold all non-zero terms	for i in range(len(op_long)):
		if op_long[i]!=0:
			op.append(op_long[i])
			pauli_terms.append(op_long[i][1])			if op_long[i][1] not in unq_pauli_terms:				unq_pauli_terms.append(op_long[i][1])	for i in range(len(unq_pauli_terms)):		ind=[]		#print pauli_terms		#print unq_pauli_terms[i]		for j in range(len(pauli_terms)):			if pauli_terms[j]==unq_pauli_terms[i]:				ind.append(j)		coeff=0		for ii in ind:			coeff=complex(op[ii][0])+coeff		#print coeff		if coeff != 0: #only incl. term if non-zero			simplified.append([coeff,unq_pauli_terms[i]])	if simplified==[]:		simplified=[0]			return simplified				def op_mult(op1,op2,n):	product=[]	op_prod_terms=[]	for t1 in range(len(op1)):		for t2 in range(len(op2)):			coeff=op1[t1][0]*op2[t2][0]			paulis=[]			#print 'term1*term2',op1[t1],op2[t2]			for q in range(n):				#print op1[t1][1][q],op1[t2][1][q]				q_term=symp_mult([1,op1[t1][1][q]],[1,op2[t2][1][q]])				coeff=coeff*q_term[0]				paulis.append(q_term[1])			term=[coeff,paulis]			op_prod_terms.append(term)	comb_terms(op_prod_terms)  #simplfy by combining like terms	return op_prod_termsdef fourthwise_prod(i,j,k,l,n):	pairwise_cr=op_mult(cr_symp(i,n),cr_symp(j,n),n)	#print pairwise_cr	pairwise_an=op_mult(an_symp(k,n),an_symp(l,n),n)	#print pairwise_an	fourth=op_mult(pairwise_cr,pairwise_an,n)	fourth=comb_terms(fourth)	return fourthdef convert(op): #converts from symplectic to paulis X, Y, Z (I for identity)	if op==[0]:		return op	else:			n=len(op[0][1])		converted=zeros([len(op),n+1],object)		for i in range(len(op)):			converted[i,0]=op[i][0]			symp_terms=op[i][1]			for q in range(len(symp_terms)):				if symp_terms[q]==[0,0]:					converted[i,q+1]='I'				elif symp_terms[q]==[1,0]:					converted[i,q+1]='X'				elif symp_terms[q]==[1,1]:					converted[i,q+1]='Y'				elif symp_terms[q]==[0,1]:					converted[i,q+1]='Z'		return converteddef pauli_sups(op):	n=len(op[0][1])	converted=zeros([len(op),1],object)	for i in range(len(op)):		terms=op[i][1]		x_sup=[]		y_sup=[]		z_sup=[]		for q in range(len(terms)):			if terms[q]==[1,0]:				x_sup.append(q)			elif terms[q]==[1,1]:				y_sup.append(q)			elif terms[q]==[0,1]:				z_sup.append(q)				term=[op[i][0]]		if len(x_sup)!=0 and term[0]!=0:			term.append('X',x_sup)		if len(y_sup)!=0 and term[0]!=0:			term.append(['Y',y_sup])		if len(z_sup)!=0 and term[0]!=0:			term.append('Z')			term.append(z_sup)		converted[i]=[term]	return converteddef term_support(term):	sup=[]	for i in range(len(term)):		if term[i]!=[0,0] and i not in sup:			sup.append[i]	return supdef op_support(op):	sup=[]	for i in range(len(op)):		for q in range(len(op[i][1])):			if op[i][1][q]!=[0,0] and q not in sup:				sup.append(q)	sup=sort(sup)	return supdef rand_hamiltonian(n): #generates hamiltonian for n orbital system with randomizaed hamiltonians	ham=[]	n_qubits=int(2**ceil(log2(n))) #the number of qubits used to map n orbitals	#first calculate the pairwise products	for i in range(n):		for j in range(n):			coeff=random.random(1)[0]			pair_terms=op_mult(cr_symp(i,n_qubits),an_symp(j,n_qubits),n_qubits)			for t in range(len(pair_terms)):				pair_terms[t][0]=pair_terms[t][0]*coeff			ham=ham+pair_terms	ham=comb_terms(ham)	#now calculate the fourthwise products	for i in range(n):		for j in range(n):			for k in range(n):				for l in range(n):					coeff=random.random(1)[0]					fourth_terms=fourthwise_prod(i,j,k,l,n_qubits)					for t in range(len(fourth_terms)):						if fourth_terms[t]!=0:							fourth_terms[t][0]=coeff*fourth_terms[t][0]					ham=ham+fourth_terms
	ham=comb_terms(ham)	if ham==[]:		ham=[0]	return hamdef pauli_weighting(ham): #computes number of times each pauli matrix acts --hamiltonian input should be in symplectic notation (as output by rand_hamiltonian)	n_x=0	n_y=0	n_z=0	for i in range(len(ham)):		for q in range(len(ham[i][1])):			if ham[i][1][q]==[1,0]:    #x pauli				n_x=n_x+1			elif ham[i][1][q]==[1,1]:  #y pauli				n_y=n_y+1			elif ham[i][1][q]==[0,1]:  #z pauli				n_z=n_z+1			else:			   #identity				assert(ham[i][1][q]==[0,0])					weights={}	weights['x']=n_x	weights['y']=n_y	weights['z']=n_z	return weights
def product_weighting(ham): #number of CNOT gates and pauli-z single qubit gates needed for a given hamiltonian (in symplectic notation)
	cnot=0
	z_sqg=0	for i in range(len(ham)):
		n=0
		for q in range(len(ham[i][1])):
			if ham[i][1][q]!=[0,0]:				n+=1
		if n!=0:
			cnot+=2*(n-1)
			z_sqg+=1	return cnot,z_sqgdef commute(term1,term2): # terms look like [a,[[p,q],[p,q],[p,q],...,[p,q]] (as they are output by the hamiltonian function)			  # where each [p,q] pauli matrix is acting on qubit equal to index	term1=term1[1] #just use the matrices of each term, don't need coefficients	term2=term2[1]	n=len(term1)	assert(n==len(term2)) #should all have length n --one pauli acting on each qubit	coeff_12 = 1.	coeff_21 = 1.	for i in range(n):		#calc. coeff for term1*term2		[p1,q1]=term1[i]		[p2,q2]=term2[i]		coeff_12=coeff_12*(1j**((p2*q1-p1*q2)*(2*(p1+p2-q1-q2)+1)))		#now calc. coeff for term2*term1		[p1,q1]=term2[i]		[p2,q2]=term1[i]		coeff_21=coeff_21*(1j**((p2*q1-p1*q2)*(2*(p1+p2-q1-q2)+1)))	if coeff_12==coeff_21:		return True	else:		return Falsedef group_terms(ham): #group terms by commutation	grouped_terms=[]	group_sizes=[]	while len(ham)>1:            a =random.randint(0,len(ham)-1)            current_group=[ham[a]]            ham.remove(ham[a])            i=0            while i<len(ham):                commuting=True                for j in range(len(current_group)):                    if commute(current_group[j],ham[i])==False:                        commuting=False			break                if commuting:                    current_group.append(ham[i])                    ham.remove(ham[i])                else:                    i=i+1            grouped_terms.append(current_group)            group_sizes.append(len(current_group))	if len(ham)==1:            grouped_terms.append(ham[0])            group_sizes.append(1)	return grouped_terms,group_sizes				def calc_n_groups(min_qubits,max_qubits):
	n_qubits=arange(1,max_qubits)
	n_ham_terms=[]
	n_groups=[]
	n_groups_err=[]
	q_group_sizes=[]
	q_group_sizes_err=[]
	n=1
	for q in range(min_qubits,max_qubits+1):
		print "qubit # =",q
		hamiltonian=rand_hamiltonian(q)
		n_ham_terms.append(len(hamiltonian))
		all_sizes=[]
		sizes=[]
		sizes_err=[]
		groups_added=[]
		all_n_groups=[]
		for i in range(n):
			ham=copy(hamiltonian)
			groups,group_sizes=group_terms(ham)
			all_n_groups.append(len(groups))
			for group in range(len(group_sizes)):
				if group<len(all_sizes):
					all_sizes[group].append(group_sizes[group])	
				else:
					all_sizes.append([group_sizes[group]])
		for group in range(len(all_sizes)):
			sizes.append(mean(all_sizes[group]))
			sizes_err.append(std(all_sizes[group]))
		n_groups.append(mean(all_n_groups))
		n_groups_err.append(std(all_n_groups))
		q_group_sizes.append(sizes)
		q_group_sizes_err.append(sizes_err)
	filename="groupdata_q"+str(min_qubits)+"-"+str(max_qubits)+"_n"+str(n)+".dat"
	qubits=arange(min_qubits,max_qubits+1)
	n_groups=array(n_groups)
	n_groups_err=array(n_groups_err)
	q_group_sizes=array(q_group_sizes)
	q_group_sizes_err=array(q_group_sizes_err)
	dat=column_stack((qubits,n_ham_terms,n_groups,n_groups_err,q_group_sizes,q_group_sizes_err))
	savetxt(filename,dat,fmt="%s")
	return [n_groups,q_group_sizes]
		
		
										def matrixTensorProduct(matrixA,matrixB):    '''takes two matrices as input, returns their tensor product. row is first index for input and output.    i'm really unconvinced that this isn't in one of the standard libraries, but i'm on a coach with no internet.'''    import numpy        numRowsA = len(matrixA)    numRowsB = len(matrixB)    numColumnsA = len(matrixA[0])    numColumnsB = len(matrixB[0])    numRowsProduct = numRowsA*numRowsB    numColumnsProduct = numColumnsA *numColumnsB        tensorProduct = numpy.empty([numRowsProduct,numColumnsProduct])        for rowIndex in range(numRowsProduct):        for columnIndex in range(numColumnsProduct):            rowFromA = int(rowIndex/numRowsB)            rowFromB = rowIndex - rowFromA*numRowsB            columnFromA = int(columnIndex/numColumnsB)            columnFromB = columnIndex - columnFromA*numColumnsB            tensorProduct[rowIndex][columnIndex] = matrixA[rowFromA][columnFromA]*matrixB[rowFromB][columnFromB]         return tensorProduct                    def commutingOplistToMatrix(oplist, outputFile = '/home/andrew/scratch/data.dat', boolPrintDebugInfo=1):    '''take in a oplist where all elements commute.  output one H matrix.    nb note oplist is list of [(coefficient), (pauli string)] entries.  see standard established above    TODO:  do a better outputFile thing.  (make it store to a temp file which is deleted on output).'''    import basics as qiBasics                                                                                                                           import scipy    import numpy    from tempfile import tempdir    import os.path as path    import sys        numQubits = len(oplist[0][1])    listMatrixTerms = []    if boolPrintDebugInfo:        print('Creating overallMatrix memory map.')        sys.stdout.flush()    overallMatrix = numpy.memmap(outputFile, dtype='float32', mode='w+', shape=(2**numQubits,2**numQubits))    overallMatrix[:] = 0.+0.j    if boolPrintDebugInfo:        print('overallMatrix memory map created.  Calculating individual matrix terms.')        sys.stdout.flush()    for index, term in enumerate(oplist):                if boolPrintDebugInfo == 1:            print('Calculating full dimensional treatment of term', index)            sys.stdout.flush()        coefficient = term[0]        pauliString = term[1]        listPauliMatrices = []                for whichPauli in pauliString: #for each pauli, get the matrix rep. of that pauli            if whichPauli == 1:                matrix = array([[0.0,1.0],[1.0,0.0]])            elif whichPauli == 2:                matrix = array([[0.,0.-1.j],[0.+1.j,0.]])             elif whichPauli == 3:                matrix = array([[1.,0.],[0.,-1.]])            else:                matrix = array([[1.,0.],[0.,1.]])            listPauliMatrices.append(matrix)        if boolPrintDebugInfo:            print('Pauli matrices created, creating tensor product represntation.')            sys.stdout.flush()        '''now generate the tensor product of the matrices for this term'''        tensoredTerm = listPauliMatrices[0]        for newPauli in listPauliMatrices[1:]:            tensoredTerm = matrixTensorProduct(tensoredTerm,newPauli)        tensoredTerm = numpy.multiply(coefficient,tensoredTerm)        listMatrixTerms.append(tensoredTerm)        if boolPrintDebugInfo == 1:        print('Full dimensional calculation of Pauli strings completed.  Summing.')        sys.stdout.flush()        for matrix in listMatrixTerms:        overallMatrix = overallMatrix + matrix        overallMatrix = numpy.asmatrix(overallMatrix) #convert to numpy matrix type for compatibility    return overallMatrixdef groupedOplistsToMatrices(oplists):    '''take a list of sets of commuting Hamiltonian terms in oplist format, return    a list of matrices representing them.'''    termList = []    for termset in oplists:        termMatrix = commutingOplistToMatrix(termset)        termList.append(termMatrix)    return termList           I = array([[1,0],[0,1]])Z = array([[1,0],[0,-1]])X = array([[0,1],[1,0]])Y = array([[0,0-1j],[0+1j,0]])     def checkCommute(oplist1,oplist2):    '''takes oplists of same length, returns true if they commute otherwise false'''    commute = True    for i in range(len(oplist1)):        if oplist1[i] and oplist2[i] and oplist1[i] != oplist2[i]:            commute = not commute    return commute                        #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  TESTS  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
